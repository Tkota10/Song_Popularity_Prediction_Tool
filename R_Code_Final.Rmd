---
title: "You’re On Aux: Exploring the Statistical Relationships Between Musical Features & Song Popularity"
author: "The ANOVA Avengers"
date: "2023-05-06"
geometry: margin = 1.5cm
output:
  pdf_document:
    toc: yes
    number_sections: yes
    toc_depth: 3
  word_document:
    toc: yes
    toc_depth: '3'
urlcolor: blue
fontsize : 10pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,      ## show or suppress the code
                      include = TRUE ,      ## show or suppress the output
                      message = FALSE,      ## omit messages generated by code
                      warning = FALSE,      ## omit warnings generated by code
                      comment = NA,         ## removes the ## from in front of outputs
                      fig.align = "center", ## centers all figures
                      fig.height = 5,     ## set the default height
                      fig.weight = 5      ## set the default width
)

# load packages
library(tidyverse)
library(ggfortify)
library(ggplot2)
library(GGally)
library(ISLR)
library(Stat2Data)
library(lubridate)
library(wordcloud)
library(tidytext)
library(dplyr)
library(tidyr)
library(car)
library(boot)
library(PerformanceAnalytics)
library(corrplot)
library(olsrr)
library(leaps)
library(gridExtra)
```

# Introduction
*Hey, you got Aux?*

One of the most anxiety inducing questions one can experience. You have the impossible task to pick a song that not only fits the mood, but also leaves everyone happy and satisfied. Conversely, imagine you’re an upcoming musician. How should you go about picking a song that maximizes plays and increases your reach? According to the Bureau of Labor Statistics, the top 1% of artists earn 77% of recorded music income. Therefore, having a tool that enables musicians to increase the chances of their song's success would be extremely valuable. In this paper, we **explore** what variables or features that best correlate with danceability—a spotify created statistic related to how “danceable” a song is-as well as total streams. Furthermore, we **identify strategies** that help ‘aux controllers’ and rising musicians maximize their chances of satisfying their respective audience! 

# Data
```{r, echo=FALSE}
songs <- read.csv("https://raw.githubusercontent.com/Tkota10/Spotify_Top_100-Songs/main/S%26DS_230_Spotify.csv")
```
In our analysis we use a dataset of the top 100 most streamed songs on spotify. The relevant columns we used are:

+ **Name** (Categorical): The name of the song

+ **Genre** (Categorical): What genre of song it’s classified as

+ **Duration** (Continuous): Measures the duration of songs in a minute

+ **Energy** (Continuous):  Represents the perceptual measure of intensity and activity associated with the song on a scale from 0.0 to 1.0

+ **Key** (Categorical): What musical key scale the song is written in

+ **Loudness** (Continuous): The overall loudness of a track in decibels (dB)

+ **Mode** (Categorical): Describes if the song is written in major or minor scale

+ **Speechiness** (Continuous): Speechiness detects the presence of spoken words in a track. The more exclusively speech-like the recording (e.g. talk) is, the higher the value is on a scale from 0-1

+ **Liveness** (Continuous): A calculated statistic that describes the probability that the song was recorded with a live audience., and higher liveness values (in our case on a scale from 0-1)

+ **Valence** (Continuous):  Describes the musical positiveness conveyed by a track on a scale from 0-1. Tracks with high valence sound more positive (e.g. happy, cheerful, euphoric), while tracks with low valence sound more negative (e.g. sad, depressed, angry)

+ **Tempo** (Continuous): The speed or pace of a given piece in beats/min

+ **Danceability** (Continuous):  Danceability describes how suitable a track is for dancing. A value of 0.0 is least danceable and 1.0 is most danceable

+ **Streams** (Continuous): The number of times the song has been listened to in billions

+ **ReleaseDate** (Categorical): Describes the specific full date(mm/dd/yy) that the track was released

+ **Season** (Categorical): What season the track was released. We use the season of fall/winter and spring/summer


# Data Cleaning
```{r, echo=FALSE}
# get rid of ID column
songs <- songs[,-1]

# fix column names 
names(songs) <- tolower(names(songs))
names(songs)[15] <- "streams"
names(songs)[16] <- "releasedate"

# fix release date format
songs$releasedate <- as.Date(songs$releasedate, format = "%d-%b-%y")

# create column releaseyear
songs$releaseyear <- format(as.Date(songs$releasedate), "%Y")

# filter the songs data frame to include only songs with less than 3 billion streams
songs <- subset(songs, streams < 3)

# replace 1's with "minor" and 0's with "major" in the "mode" column
songs$mode <- ifelse(songs$mode == 1, "Minor", "Major")

# code to convert data into non-scientific notation: 
songs$acousticness <- sprintf("%.5f", songs$acousticness)

# code to convert data into non-scientific notation: 
songs$instrumentalness <- sprintf("%.5f", songs$instrumentalness)

# change key from number to musical key - 0 = C, 1 = C#, etc. 
songs$key <- ifelse(songs$key == 0, "C", 
             ifelse(songs$key == 1, "C#", 
             ifelse(songs$key == 2, "D", 
             ifelse(songs$key == 3, "D#", 
             ifelse(songs$key == 4, "E", 
             ifelse(songs$key == 5, "F",
             ifelse(songs$key == 6, "F#", 
             ifelse(songs$key == 7, "G",
             ifelse(songs$key == 8, "G#", 
             ifelse(songs$key == 9, "A", 
             ifelse(songs$key == 10, "A#", 
             ifelse(songs$key == 11, "B", "Unknown"))))))))))))

# create column release month and create seasons column (Spring/Summer or Fall/Winter)
songs$releasemonth <- format(as.Date(songs$releasedate), "%B")
songs$season <- ifelse(songs$releasemonth %in% 
                         c("March", "April", "May", "June", "July", "August"), 
                       "S/S",
                    ifelse(songs$releasemonth %in% 
                             c("September", "October", "November", "December", 
                               "January", "February"), "F/W", "Unknown"))

# delete rows with NA's
songs <- na.omit(songs) 
```

This R code performs data **cleaning** and **transformation** operations on a dataset named "songs". The code first removes the ID column and standardizes column names to lowercase. The code changes the date format of the "releasedate" column, **creates** a new "releaseyear" column, and **subsets** the data to include only songs with less than 3 billion streams. The code replaces 1's and 0's in the "mode" column with "Minor" and "Major", respectively. The code also **formats** data in the "acousticness" and "instrumentalness" columns using the sprintf function. Numeric values in the "key" column are replaced with musical key names. The code creates two new columns, "releasemonth" and "season", and **removes** rows with missing values.

# Descriptive Plots & Summary Information
## Boxplots / T-Tests
```{r, echo=FALSE}
plot11 <- ggplot(songs, aes(x = mode, y = streams, fill = mode)) +
  geom_boxplot(outlier.colour = "red",
        outlier.shape = 2,
        outlier.size = 3) +
  stat_summary(fun = "median",
               geom = "point",
               shape = 21,
               size = 3,
               fill = "white",
               color = "black") +
  stat_summary(fun = "median",
               geom = "text",
               size = 3,
               aes(label = paste0("Median = ", round(..y.., 2))),
               vjust = -1) +
  labs(x = "Mode", y = "Streams") +
  ggtitle("Boxplot of Streams by Mode") +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("darkolivegreen1", "cornsilk4"))
plot22 <- ggplot(songs, aes(x = mode, y = energy, fill = mode)) +
  geom_boxplot(outlier.colour = "red",
        outlier.shape = 2,
        outlier.size = 3) +
  stat_summary(fun = "median",
               geom = "point",
               shape = 21,
               size = 3,
               fill = "white",
               color = "black") +
  stat_summary(fun = "median",
               geom = "text",
               size = 3,
               aes(label = paste0("Median = ", round(..y.., 2))),
               vjust = -1) +
  labs(x = "Mode", y = "Energy") +
  ggtitle("Boxplot of Energy by Mode") +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("darkolivegreen1", "cornsilk4"))
plot33 <- ggplot(songs, aes(x = mode, y = danceability, fill = mode)) +
  geom_boxplot(outlier.colour = "red",
        outlier.shape = 2,
        outlier.size = 3) +
  stat_summary(fun = "median",
               geom = "point",
               shape = 21,
               size = 3,
               fill = "white",
               color = "black") +
  stat_summary(fun = "median",
               geom = "text",
               size = 3,
               aes(label = paste0("Median = ", round(..y.., 2))),
               vjust = -1) +
  labs(x = "Mode", y = "Danceability") +
  ggtitle("Boxplot of Danceability by Mode") +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("darkolivegreen1", "cornsilk4"))
plot44 <- ggplot(songs, aes(x = mode, y = valence, fill = mode)) +
  geom_boxplot(outlier.colour = "red",
        outlier.shape = 2,
        outlier.size = 3) +
  stat_summary(fun = "median",
               geom = "point",
               shape = 21,
               size = 3,
               fill = "white",
               color = "black") +
  stat_summary(fun = "median",
               geom = "text",
               size = 3,
               aes(label = paste0("Median = ", round(..y.., 2))),
               vjust = -1) +
  labs(x = "Mode", y = "Valence") +
  ggtitle("Boxplot of Valence by Mode") +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("darkolivegreen1", "cornsilk4"))
grid.arrange(plot11, plot22, plot33, plot44, ncol = 2)
```

```{r}
(test1 <- t.test(songs$streams ~ songs$mode, conf.level = 0.95))
(test4 <- t.test(songs$danceability ~ songs$mode, conf.level = 0.95))
(test6 <- t.test(songs$energy ~ songs$mode, conf.level = 0.95))
(test8 <- t.test(songs$valence ~ songs$mode, conf.level = 0.95))
```
In music theory, major keys are associated with sounding “happier and brighter,” while minor keys sound “sadder and gloomier.” If you’re trying to bring energy, danceability, and valence (happiness) to a party, should you only play songs in major keys, then? 
 
From the box plots, it appears as though the median values of the major mode are **generally higher** than those of the miner mode, other than when looking at energy. However, according to the t tests, all with p-values far above our alpha of 0.05, there is **no statistically significant difference** in the median streams, danceability, energy, or valence based on mode. 


```{r, echo=FALSE}
plot10 <- ggplot(songs, aes(x = season, y = streams, fill = season)) +
  geom_boxplot(outlier.colour = "red",
        outlier.shape = 2,
        outlier.size = 3) +
  stat_summary(fun = "median",
               geom = "point",
               shape = 21,
               size = 3,
               fill = "white",
               color = "black") +
  stat_summary(fun = "median",
               geom = "text",
               size = 3,
               aes(label = paste0("Median = ", round(..y.., 2))),
               vjust = -1) +
  labs(x = "Seasons", y = "Streams") +
  ggtitle("Boxplot of Streams by Season") +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("cadetblue1", "coral"))
plot12 <- ggplot(songs, aes(x = season, y = energy,
                            fill = season)) +
  geom_boxplot(outlier.colour = "red",
        outlier.shape = 2,
        outlier.size = 3) +
  stat_summary(fun = "median",
               geom = "point",
               shape = 21,
               size = 3,
               fill = "white",
               color = "black") +
  stat_summary(fun = "median",
               geom = "text",
               size = 3,
               aes(label = paste0("Median = ", round(..y.., 2))),
               vjust = -1) +
  labs(x = "Seasons", y = "Energy") +
  ggtitle("Boxplot of Energy by Season") +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("cadetblue1", "coral"))
plot13 <- ggplot(songs, aes(x = season, y = danceability,
                            fill = season)) +
  geom_boxplot(outlier.colour = "red",
        outlier.shape = 2,
        outlier.size = 3) +
  stat_summary(fun = "median",
               geom = "point",
               shape = 21,
               size = 3,
               fill = "white",
               color = "black") +
  stat_summary(fun = "median",
               geom = "text",
               size = 3,
               aes(label = paste0("Median = ", round(..y.., 2))),
               vjust = -1) +
  labs(x = "Seasons", y = "Danceability") +
  ggtitle("Boxplot of Danceability by Season") +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("cadetblue1", "coral"))
plot14 <- ggplot(songs, aes(x = season, y = valence,
                            fill = season)) +
  geom_boxplot(outlier.colour = "red",
        outlier.shape = 2,
        outlier.size = 3) +
  stat_summary(fun = "median",
               geom = "point",
               shape = 21,
               size = 3,
               fill = "white",
               color = "black") +
  stat_summary(fun = "median",
               geom = "text",
               size = 3,
               aes(label = paste0("Median = ", round(..y.., 2))),
               vjust = -1) +
  labs(x = "Seasons", y = "Valence") +
  ggtitle("Boxplot of Valence by Season") +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("cadetblue1", "coral"))
grid.arrange(plot10, plot12, plot13, plot14, ncol = 2)
```

```{r}
(test1 <- t.test(songs$streams ~ songs$season, conf.level = 0.95))
(test3 <- t.test(songs$energy ~ songs$season, conf.level = 0.95))
(test4 <- t.test(songs$danceability ~ songs$season, conf.level = 0.95))
(test8 <- t.test(songs$valence ~ songs$season, conf.level = 0.95))
```
“Songs of the summer” are, traditionally, high-energy songs that reach their commercial peak in summer. Therefore, if you’re trying to bring good vibes to a party, should you primarily choose songs released during spring/summer, rather than during the colder, busier months of fall/winter? 

According to the boxplots... maybe. Visually, it appears as if songs released in spring/summer have **higher median streams, higher median energy, and higher median danceability** (but not higher median valence) than songs released in fall/winter. According to the t tests, though, which all have p values greater than 0.05, there is **no statistically significant difference** in the median streams, energy, danceability, or valence based on season. 


## Scatterplots / Correlation Tests
We ran scatterplots to see if there were any correlations with streams or danceability. Are there any traits a new musician should try to put in their song to ensure its commercial success? And are there any musical features that ensure that a track is “danceable?”

```{r, echo=FALSE}
library(gridExtra)

plot1 <- ggplot(songs, aes(x = streams, y = energy)) +
  geom_point(col = "aquamarine4") +
  labs(x = "Streams", y = "Energy") +
  ggtitle("Scatterplot of Streams by Energy") +
  theme(plot.title = element_text(hjust = 0.5, size = 10))
plot2 <- ggplot(songs, aes(x = streams, y = danceability)) +
  geom_point(col = "black") +
  labs(x = "Streams", y = "Danceability") +
  ggtitle("Scatterplot of Streams by Danceability") +
  theme(plot.title = element_text(hjust = 0.5, size = 10))
plot3 <- ggplot(songs, aes(x = streams, y = loudness)) +
  geom_point(col = "orange") +
  labs(x = "Streams", y = "Loudness") +
  ggtitle("Scatterplot of Streams by Loudness") +
  theme(plot.title = element_text(hjust = 0.5, size = 10))
plot4 <- ggplot(songs, aes(x = streams, y = valence)) +
  geom_point(col = "blue") +
  labs(x = "Streams", y = "Valence") +
  ggtitle("Scatterplot of Streams by Valence") +
  theme(plot.title = element_text(hjust = 0.5, size = 10))
grid.arrange(plot1, plot2, plot3, plot4, ncol = 2)
```

```{r}
cor(songs$energy, songs$streams)
cor(songs$danceability, songs$streams)
cor(songs$loudness, songs$streams)
cor(songs$valence, songs$streams)
```
Above, we created scatterplots to analyze the relationship between total streams and other variables within the dataset: **Energy, Danceability, Loudness, and Valence**. The streams and energy scatterplot has a **slight negative correlation** at -0.374995 as well as light clustering in the upper left corner of the plot. The streams and danceability scatterplot has a **minimal positive correlation** at 0.01257812 with a larger density of data points on the left side of the plot. The scatterplot of streams and loudness has a **slight clustering** of data points in the top left and the scatterplot has a light negative correlation around -0.2093497. Finally, the scatterplot of streams and valence has a **slight negative correlation** at -0.1395527 as well as a slightly denser concentration of data points on the left side of the plot. Overall, there are **no major relationships **between streams and energy, danceability, loudness, or valence. However, energy, loudness, and valence have **slight negative correlations **while danceability has a **slight positive correlation**. 

```{r, echo=FALSE}
p1 <- ggplot(songs, aes(x = danceability, y = duration)) +
  geom_point(col = "chocolate") +
  labs(x = "Danceability", y = "Duration") +
  ggtitle("Scatterplot of Danceability by Duration") +
  theme(plot.title = element_text(hjust = 0.5, size = 10))
p2 <- ggplot(songs, aes(x = danceability, y = loudness)) +
  geom_point(col = "orange") +
  labs(x = "Danceability", y = "Loudness") +
  ggtitle("Scatterplot of Danceability by Loudness") +
  theme(plot.title = element_text(hjust = 0.5, size = 10))
p3 <- ggplot(songs, aes(x = danceability, y = valence)) +
  geom_point(col = "blue") +
  labs(x = "Danceability", y = "Valence") +
  ggtitle("Scatterplot of Danceability by Valence") +
  theme(plot.title = element_text(hjust = 0.5, size = 10))
p4 <- ggplot(songs, aes(x = danceability, y = streams)) +
  geom_point() +
  labs(x = "Danceability", y = "Streams") +
  ggtitle("Scatterplot of Danceability by Streams") +
  theme(plot.title = element_text(hjust = 0.5, size = 10))
grid.arrange(p1, p2, p3, p4, ncol = 2)
```

```{r}
cor(songs$danceability, songs$duration)
cor(songs$danceability, songs$loudness)
cor(songs$danceability, songs$valence)
cor(songs$danceability, songs$streams)
```
Here, we have created scatterplots to analyze the relationship between Danceability and other variables within the dataset: **Duration, Loudness, Valence, and Streams**. The danceability and duration scatterplot has a **slight negative correlation** at -0.2112502 but the data points are relatively **well spread out** across the plot, slightly denser towards the bottom of the graph. The scatterplot of danceability and loudness has a slight clustering of data points in the top portion of the plot with a *light positive correlation* around 0.1247894. The scatterplot of danceability and valence has a **slight positive correlation** at 0.3611559 with a quite even distribution of data points across the plot. Finally, the danceability and streams scatterplot has a **minimal positive correlation** at 0.01257812 with a larger density of data points on the bottom half of the plot. Overall, there are *no major relationships* between danceability and duration, loudness, valence, or streams. However, loudness, valence, and streams have **slight positive correlations** while duration has a **slight negative correlation**. 

## Histogram 
Next, we were curious about the distribution of streams within this dataset. 
```{r, echo=FALSE}
hist(songs$streams, breaks = 30,
     main = "Histogram of Streams (in Billions)",
     xlab = "Streams (in Billions)",
     col = "plum")
```

Based on the histogram, it appears that the variable “streams” is **heavily right-skewed**. This means that their are few songs of our dataset with very high streams, which pull the data out, causing the histogram to be right-skewed. 

## Correlations Plot
We ran these following plots to visually see the correlations and significance values.
```{r, echo=FALSE}
source("http://www.reuningscherer.net/s&ds230/Rfuncs/regJDRS.txt")
songs.cor <- songs[ , c("danceability", "duration", "energy", "loudness", "speechiness", "liveness", "valence", "tempo", "streams")]

sigcorr <- cor.mtest(songs.cor, conf.level = .95)
corrplot.mixed(cor(songs.cor), lower.col="black", upper = "ellipse", tl.col = "black", number.cex=.7, 
                tl.pos = "lt", tl.cex=.7, p.mat = sigcorr$p, sig.level = .05)

```

## Correlation Chart 
```{r, echo=FALSE}
library(PerformanceAnalytics)
chart.Correlation(songs.cor, histogram = TRUE, pch = 19)
```
The above two plots display the correlations between our continuous variables in our dataset. The correlations with no X's are significant correlations (or ones with asterisks). There is a higher relative significant correlation between danceability and valence. Is valence truly as strong of a predictor of danceability as it appears? We ran a bootstrap to find out. 

## Bootstrap Test
```{r, echo=FALSE}
#set.seed(230)

#(cor1test <- cor.test(songs$energy, songs$danceability, conf.level = .95))

#N <- nrow(songs)

#n_samp <- 10000

#corResults <- rep(NA, n_samp)

#for(i in 1:n_samp){
 # s <- sample(1:N, N, replace = T)
  #fakedata <-  songs[s, ]
  #corResults[i] <- cor(fakedata$energy, fakedata$danceability)
#}

#(ci_r <- quantile(corResults, c(.025, .975)))

#hist(corResults, xlab = "Sample Correlation",
 #    main = "Bootstrapped Correlation",
  #   col = "darkslategray1",
   #  breaks = 50)
#abline(v = ci_r, lwd = 3, col = "midnightblue")
#abline(v = cor1test$conf.int, lwd = 3, col = "gray48", lty = 2)
#legend("topleft", c("Theoretical CI", "Boot CI"), 
 #      lwd = 3, col = c("gray48", "midnightblue"), 
  #     bg = "white", lty = c(2, 1))

set.seed(230)

(cor1test <- cor.test(songs$valence, songs$danceability, conf.level = .95))

N <- nrow(songs)

n_samp <- 10000

corResults <- rep(NA, n_samp)

for(i in 1:n_samp){
  s <- sample(1:N, N, replace = T)
  fakedata <-  songs[s, ]
  corResults[i] <- cor(fakedata$valence, fakedata$danceability)
}

(ci_r <- quantile(corResults, c(.025, .975)))

hist(corResults, xlab = "Sample Correlation",
     main = "Bootstrapped Correlation",
     col = "darkslategray1",
     breaks = 50)
abline(v = ci_r, lwd = 3, col = "midnightblue")
abline(v = cor1test$conf.int, lwd = 3, col = "gray48", lty = 2)
legend("topleft", c("Theoretical CI", "Boot CI"), 
       lwd = 3, col = c("gray48", "midnightblue"), 
       bg = "white", lty = c(2, 1))
```
It can be seen that the normal distribution of sample correlations does not appear to include 0, and both the theoretical and bootstrapped confidence intervals do not include 0. The Boot CI appears slightly narrower than the theoretical confidence interval. The bootstrapped 95% confidence interval is from 0.193 to 0.508, suggesting that there is a **statistically significant correlation between valence and danceability**.

## Permutation Test
```{r, echo=FALSE}
set.seed(230)

N <- 10000

diff <- rep(NA, N)

for(i in 1:N){
  fakeseason <- sample(songs$season)
  diff[i] <- median(songs$danceability[fakeseason == "S/S"]) - 
    median(songs$danceability[fakeseason == "F/W"])
}

hist(diff,
     main = "Permuted Sample Median Differences in Danceability",
     xlab = "Danceability",
     col = "aquamarine",
     breaks = 20)

actualdiff <- median(songs$danceability[songs$season == "S/S"]) - 
    median(songs$danceability[songs$season == "F/W"])

text(actualdiff - .01, 800, paste("Actual Diff in Medians =", round(actualdiff,2)), srt = 90, cex = .7)
abline(v = actualdiff,
       col = "maroon",
       lwd = 3)

mean(abs(diff) >= abs(actualdiff))
```
For our permutation test, we wanted to gauge **if there was a statistically significant difference** in median danceability depending on the season a song was released in. We permuted season groups, calculated medians from our “fake” data, and repeated this process 10000 times. Because our permutation test two sided p value of 0.3884 is > alpha = 0.05, we **fail to reject the null hypothesis** and **cannot say that there is a significant difference** between the median danceability of songs released in spring/summer and the danceability of songs released in fall/winter.

# Analysis
## Multiple Regresssions / Normal Quantile Plot
We began our multiple regression with 9 variables: danceability (the intercept), duration, energy, loudness, speechiness, liveness, valence, tempo, and streams. The plan was to use multiple models to analyze r-squared, adjusted r-squared, BIC, and CP Statistic in order to minimize the variables used in the model while maximizing its effectiveness to **create a model that would best correlate with danceability**. The r-sqaured values indicated that the best model would include all 8 additional variables with an r-sqaured value of 0.21. The adjusted r-squared values indicated that the best model would have an adjusted r-sqaured of 0.17 and would contain 5 additional variables: duration, energy, loudness, speechiness, and valence. The BIC values took this model minizing goal much further by indicated the best value, at -4.5, would use a model with only 1 variable: valence. Attempting to find a happy medium while maintaining the accuracy of our model, **we settled on the CP Statistic**. The CP Statistic suggested a model with three variables alongside danceability: **duration, speechiness, and valence**. 

```{r, echo = FALSE}
mod1 <- regsubsets(danceability ~ ., data = songs.cor, nvmax = 8)
mod1sum <- summary(mod1)
#mod1sum$which

#which.max(mod1sum$rsq)
#names(songs.cor)[mod1sum$which[which.max(mod1sum$rsq), ]][-1]
#songstemp <- songs.cor[ ,mod1sum$which[which.max(mod1sum$rsq), ]]
#summary(lm(danceability ~ ., data = songstemp))
#plot(mod1, main = "Best Model According to R-squared", scale = "r2")

#which.max(mod1sum$adjr2)
#names(songs.cor)[mod1sum$which[which.max(mod1sum$adjr2), ]][-1]
#songstemp <- songs.cor[, mod1sum$which[which.max(mod1sum$adjr2), ]]
#summary(lm(danceability ~ ., data = songstemp))
#plot(mod1, main = "Best Model According to Adjusted R-squared", scale="adjr2")

#which.min(mod1sum$bic)
#names(songs.cor)[mod1sum$which[which.min(mod1sum$bic), ]][-1]
#songstemp <- songs.cor[,mod1sum$which[which.min(mod1sum$bic), ]]
#summary(lm(danceability ~ ., data = songstemp))
#plot(mod1, main = "Best Model According to BIC", scale="bic")

#songstemp <- (songs.cor)[ , mod1sum$which[which.min(mod1sum$bic), ]]
#modfin <- lm(danceability ~ ., data = songstemp)
#summary(modfin)
#modnum <- which.min(mod1sum$bic) 
#names(which(mod1sum$which[modnum,] == TRUE))
#mod1sum$bic[which.min(mod1sum$bic)]
```

```{r, echo=FALSE}
modnum <- min(c(1:length(mod1sum$cp))[mod1sum$cp <= c(1:length(mod1sum$cp)) + 1])
names(songs.cor[mod1sum$which[modnum,]][-1])
songstemp <- songs.cor[,mod1sum$which[modnum,]]
# summary(lm(danceability ~ ., data = songs.cor))

lm <- lm(danceability ~ valence + speechiness + duration, data = songs.cor)
summary(lm)

myResPlots2(lm)

```
The multiple R-squared for this model is 0.1429, indicating that the models explain around 14% of the variance in danceability, which is relatively low. Regarding the significance of the independent variables, **valence is the only variable that is significant in both models** with a p-value less than 0.05. The coefficient for valence is **positive**, indicating that as valence increases, danceability tends to increase. However, the coefficients for speechiness and duration are not significant in the second model. The p-value for speechiness is 0.13059, which is greater than 0.05, and the p-value for duration is 0.18642. Overall, the results suggest that **valence is the most important variable in predicting danceability**, while speechiness and duration may not be as significant. The normal quantile plot of the studentized residuals and the fits v. residuals plot suggest that the assumptions of normality and homoscedasticity are met, indicating that the linear regression model is appropriate for the data. Because of this, **there was no need to transform the data as we saw no signs of heteroskedasticity in our complete multiple regression’s model**. 

The adjusted r-squared model seemed to overfit the data by using too many variables, while the BIC model oversimplified and may not be the best in terms of predictive accuracy. The CP statistic seemed to be the best proposed model because it took into account both the goodness of the fit and the model complexity, **striking a balance between overfitting and underfitting the given data.**

## ANOVA (avengers) 
```{r, echo=FALSE}
attach(songs)
combo <- as.factor(paste(mode, season))

print("SD by Combo")
(sds <- tapply(danceability, combo, sd))
print("Ratio of Max/Min Sample SD")
round(max(sds)/min(sds), 1)

#Trying 2-way ANOVA of Mode and Season on Danceability
boxplot(danceability ~ mode + season, col = 'red', las = 1, cex = .5, xlab = "Mode & Season",
        main = "Boxplot of Danceabilty by Mode & Season")

interaction.plot(mode, season, danceability, type = 'b', lwd = 3, col = c('red','blue','black'), 
                 main = "Interaction Plot of Mode and Season Type", xlab = "Mode", ylab = "Danceability")

danceaov <- aov(danceability ~ mode + season + mode*season)
summary(danceaov)
dancelm <- lm(danceability ~ mode + season + mode*season -1)
summary(dancelm)

combo <- as.factor(paste(mode, season))
danceaov2 <- aov(danceability ~ combo)

par(mar = c(5, 5, 4, 2))
plot(TukeyHSD(danceaov2), las = 1)

par(mar = c(5, 5, 4, 2))
myResPlots2(danceaov2)
```
We ran a 2-way ANOVA to **model the effects of mode, season, and the interaction between mode and season on danceability**. The ratio of max/min sample deviation between danceability and the combo of mode and season is 1.3, so **equal variances can be assumed**. The interaction plots do not display any interaction between mode and the season in which a song was released. Finally, we fit our ANOVA model and displayed the Tukey plots of the 95% confidence intervals which all contain 0 within their intervals, showing that there is no **significant relationship between danceability and mode, season, or their combination.** 

According to the qq plots and fits vs studentized residual plots, the data appears **approximately normal** and there does **not appear to be significant skewness**. It appears as if the standard deviation of the residuals is constant, and there are **no clear outliers** with any studentized residuals greater than an absolute value of 3. There **does not appear to be heteroskedasticity.** 

# Conclusion/Summary

In our paper, we **discovered statistically significant relationships** between musical features and streams/danceability. These are Energy & Streams (-0.37 correlation), Valence & Danceability (0.36 correlation), Duration & Danceability (-0.21 correlation), and Loudness & Loudness (-0.21). On the other hand, we observed **no considerable variations** between the song characteristics and the song's mode or release season. With these results in mind, it would be beneficial for the aux controller or aspiring musician to choose/create a song that is **mellow, on the shorter side and filled with positive lyrics**. To reaffirm and gain greater accuracy of results, we recommend rerunning the analysis described in this paper, on a dataset of all songs on spotify, rather than the top 100 streamed songs.







